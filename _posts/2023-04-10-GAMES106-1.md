---
layout: article
title: GAMES106-1 图形绘制流水线的基本原理与实践(一)
tags: ["Computer Graphics", "GAMES106", "Vulkan"]
key: 
aside:
  toc: true
sidebar:
  nav: GAMES106
---

> 本文是GAMES106-现代图形绘制流水线原理与实践([GAMES 106: Intro to Modern Rendering Pipeline](https://zju-rendering.github.io/games106/))的课程笔记。这节课程的主要内容是介绍Vulkan的基本架构和绘制流程。
<!--more-->




OK，然后，嗯，我来大概讲一下，我这个第一课时主要应该是从那个 work 这个的API，大家想要通过学习work，然后来可以实践上手来学习。嗯，这个课一开始来上的时候跟我说有个目标，就是说我们之前上了很多课，有点高屋建立，想要更从实际的角度来让大家学习到如何学习绘制，如何实际的从 Ri 接口来学习。然后这样子的话，然后我也大致概以这个目标，然后设计了一下我的那个课程安排。然后首先我来讲一下大概是谁适合比较适合这门课，就是一个是刚刚开始接触学习 IHI 的初学者，比如说你之前可能已经有过了解了 open g o 或者第三、第十一或者，嗯，别的什么之类的，你对于这整个绘制的东西你还要想要更深入的了解，这个是对。然后但假如说你对于沃肯这个东西其实已经比较熟悉了，对，或者管线什么之类都非常熟悉了，这门课可能，嗯，我觉得可能意义就不是没有特别大了。
然后第二个的话，我们是有一个前置的要求，就是你必须首先要学会 c 和 C + + OK，然后这门这些课在我上的时候你可以收获的东西一个是 work API 的一个基本使用，第二个是对于 work 的绘制管线的一个相对来说全面一点的一个理解。最后是因为我一直在从事的都是移动端上的一些应用开发，然后会讲一些针对，可能会提起一些针对移动端的优化的实践，然后我为什么要区分移动端跟那个桌面端这个事情是因为，嗯，会 h i 接口其实是一个面向硬件开发的一个一个一种接口，也就是说你的同样的代码，你在不同的平台，他们的硬件给你设置的那个 bug 是什么样子？其实不一样的。这个就类似于那个木桶理论，你的木桶影响你速度最高的木桶是那个最短的那块板。
然后 PC 端上的一些就移动端上可能是一些问题，在 PC 上可能它就不是问题了。比如说移动端它的，我相信 g p u 的那个计算性能其实还是可以的。现在但是移动端上的它的瓶颈是在于带宽上面，所以说我们在 PC 上可能会很容易的用一些算法，可能跑得非常好，但跑到移动端上你就发现就特别的卡，原因也是出于这种东西，所以说在，嗯，OK。






然后所以说这个东西可能要区分不同的硬件平台，哪怕同样是移动端，你安卓、iOS，或者你哪怕是安卓，你是高通的卡，还是说是华为的那个麒麟或者联发科的，其实对他们都要做有可能有不一样的那个针对性的优化，那么你这个才是一个高性能的一个东西了。OK，然后下面我再讲一下我们的课程安排，然后我的课程安排总共是有三节课，那个第一个是 work 的基础架构，然后它的绘制流程，然后基本上大概这门课的安排就是说我大概会讲一下你这个，我可能会去怎么去架构它，然后怎么去初始化一个 woken 的一个application。然后第二课呢是我们walking，你我们最关键的一部分，你要去绘制它，然后怎么去创建 work 的绘制对象，然后内存管理以及最重要的事情是它出问题了，你要怎么去调试？你要还有一些工具的使用，我们离不开这个 work 的工具。
然后最后一节课会有一个work，就是我们所说的现代图形管线的一个很重要的一个事情，就是多形成同步，当然还会一些基于移动端的一些常见的优化还有实践。然后最后是看一下那个作业还有反馈，OK，然后这个是我们的这个课程的一个目录，然后第一个沃克的简介，沃克它跟 open g o 比较类似，毕竟一开始在提出 work 这个东西的时候，它的名字不叫work，是叫 go next，就是下一代的 open g o。然后所以说它也跟 open g o 一样，其实是有一个官方的标准，我们定好了一个统一的接口，统一的标准，那么具体的实现，OK，你们每个硬件厂商自己去实现，并没有一个组织去审核你的这个硬件实验的能力。然后这个区分于苹果的 metal 或者 D3D10 一12，不一样的地方，就在这个地方，你在 D3D 10 一12，当你的文档标准里面说它支持这个功能，或者说当你 query 出你的硬件，你的设备、你的系统能够支持这个功能的时候，那么它一定是有的。但是在 washen 的或者 open 解耦 walking 的那一套里面其实是不一定的。
这个事情是要打个问号的，就是说他们可能很声称了我支持了Walking，现在是 1. 3，可能他们可能声称了自己生成了 walking 1. 11. 2 的核心功能，但是它并不是真的所有的核心功能它都实现了，你只能去经过一些测试，它才可能某些功能是 OK 的，某些功能其实是不 OK 的。然后还有一个是work，相对于那个，嗯，他做一个开源的那个框架的话，主要还有一个特征就是扩展，每个平台会有一个自己的扩展，比如说在 retracting 刚出来的时候，就在 n 卡上沃克的 n 卡有一个 register 的扩展，然后这个扩展在 MD 的上面你是用不了的。你在手机端上也是用不了的，因为它是针对于那个恩卡的一个扩展，然后在后续的你的扩展可能就会被吸收到了那个沃克的核心的功能里面。
所以说我们在看到 working 的很多函数的时候，会经常看到一些后缀，两个函数几乎长得一样的都是 v k 叉，然后 NV 或者 VKX 叉，华为OK，这也是华为做的扩展，然后 VKX 叉 AMD OK，这是 AMD 的扩展，然后 VKX 叉叉Android，这是安卓上的一个扩展。
所以说我们 work 在开发的时候，这个是需要注意一下你想用它的某些功能，那个功能其实跟你的那个硬件设备，或者说你的跟着你的显示平台是非常强相关的一个事情。okay，然后后面我们要看一下，首先我们去 welcome 的话，学习的话，首先我们要去下载。20，OK，首先我们去 work 的这个平台上，我们去下载它的SDK。这个 SDK 的话我们可以看到Windows、 Linux 跟Mac， Windows 跟 Lynx 都是官方出的一些版本，但是 Mac 并不是苹果出的，是那个 v 色做的一个哎呦，是威瑟做的，做的一个功能。OK，弹幕有人说是 KHR 是什么后缀？这个 KHR 其实就是那个给制造沃克的那个官方组织做的一个扩展的一个后缀，你可以把它理解成一个类似于官方的扩展功能。对，下面有弹幕有说，就是，对，这是，就是这个组织做的一个。
对，你可以把它理解成一个官方的后缀。OK，我们接下来聊一下，然后我们安卓的那个功能的话，我看是那个是是谷歌提供的，然后跟你的 NDK 随着你的NDK，然后附带着出去，然后最后的实现当然是根据你不同手机硬件来实现这个事情会有一个。嗯，那个大家可能会在桌面端开发沃克的时候会体验可能会更好一点，为什么呢？因为沃克桌面上只有三家，那个驱动厂商NM、media、MD，英特尔只有这三家。然后这三家我的经验是大家尽量，如果后面的作业大家尽量，如果手头上有独立的显卡，那么尽量用独显来实现来去完成这个作业，而不要用那个英特尔的和谐。
如果大家的作业有兴趣的话，也可以在移动端上跑安卓或者iOS，然后安卓的话我的经验是，会有录屏的，对，后面会上传的，然后安卓的，有人问那个老师有录屏吗？这个会有录屏的，然后那个安卓的那个驱动的话，就是每个手机厂商会有的不同的实现，你华为手机就是华为实现的， OPPO 手机就是OPPO，但是有些像小米可能也是小米实现的，然后高通的手机，小米、 OPPO 他们使用的高通手机，高通会有一个提供那个一个大概的一个驱动，然后华为跟高通就不一样。然后我的实践就是可能高通的手机它的兼容性、鲁棒性会更强一点，华为或联发科他们的这种支持可能就会弱一点，就是会出现我说的那种核心是支持的，但是其实他手机并不支持。比如说有一个叫 MSAA 的功能，你在我们开了MSA，你会发现很多比较低端的什么高通 6 系、 4 系手机可能就跑不起来了，直接就崩溃了。但是你把这个 MSA 一关 OK 了，那么他只能说我只能去理解成它的驱动，对这个知识是有一点问题的。
OK，然后我们下面是讲一下对比那个传统的 HI 跟现代HI，因为沃肯第三、第十二跟mental，我们可以按照说是现代的RHI，然后传统的HI，其实他们会有一个叫做上下文的一个概念，他们是一个状态机，这个 context 可能有。像 open go 会有个隐式的context，它跟你的线程是绑定的。
然后 DX 第 3D 会有一个显示的context，有个叫什么 ID 3D divorce contest 这么一个对象，那这个对象里面它也是一个状态机，当你改了一个什么东西，它就会有个状态会记录在这个里面。这个状态机的这个东西有什么不好？我可以举一个例子，嗯，比如说我们开发了一个 SDK 开发的功能，用 open Gu 开发的功能，OK，我们自己去管理了一些设备，管理一些图片的纹理，我们自己去建了。然后假如说它篇刚好有个图片纹理，它的就是字母12，因为 OPEN 9 它那个图片对象它就是一个整形，我们就是12，然后外面在调用我们这个 SDK 的人，他们就外面会，也会有他们的对应的图片资源。那么假如运气非常不好，他的代码写的，嗯，有问题。
他们很久以前就是有一个纹理 ID 叫 12 的，这么一个纹理已经释放掉了，但是他并没有把这个 12 这个给置为0，然后等到后面他再想去回收资源的时候，发现我有个纹理12，好，我想去把它给释放掉，然后他以为释放的是外面的对象，那么但是真正释放的是我们提供的一个 SDK 内部的一个纹理，然后就会发生一些一些不可控的或者无法预期的问题了，可能程序会崩溃或者只是黑屏或者怎么样？然后对接我们的 SDK 的人就会觉得，唉，你这 SDK 有问题，你看我用了你的SDK，你看我的这个程序就崩溃了，那么好吧，这个问题你要去解决了。然后这种东西我们也知道这很难查，因为这个逻辑并不是我们能够控制的，是外部的错误调用来导致的。然后这个就是，嗯，传统 h i open g o 会带来的一方面的这种问题，它的状态机管理，你外部如果修改了，我内部其实是无法感知的。
然后第二个事情是驱动，会帮你干很多事情，传统 h i 的驱动它会帮你做同步，比如说你想 open 解欧，你想从那个纹理里面去把贴图读出来，那么这个时候就会有个隐式的同步，它会让把那个所有跟输出到这张贴图的渲染相关的所有的命令都结束了之后。OK，那我再去从这样贴图里面把这个东西给读出来，然后这些事情都是驱动帮你干了。
你在写的时候你会感觉好像这个那个函数我们记错了，叫 g o red Pixel，这个函数会特别的慢，但这个慢并不是它卡着了，或者说这个函数很慢，只是因为 CPU 在等， GPU 在干活，就是 CEO 在那喊，唉，继续你快点干，我就等着要你的结果。然后继续又说，好好好，你慢慢等，你慢慢稍微再等一等，我马上就好了，OK，然后等到 GPU 干完活了，然后 CPU OK，再把这个你干出来的结果给拿出来。
这种东西好处就是说，当然你在写代码的人开发这个功能当然是非常开心的，因为保证的结果是正确的。当然另一个方向你想要写的非常高效，你就没有任何手段了。然后所以说，所以欧本机油的驱动一般来说就会比较重，他们或者D3、 D11 的驱动就会很重很重，因为它要保证你的所有的功能都是完善的，所有的东西都是 OK 的。然后所以他帮你做好多事情，包括同步竞争，比如说，嗯，你这个东西你谁先用，然后又有谁先读之类的。假如说你还有了写了多线程，当然我们 open 9 也是可以写多线程的了，嗯之类的事情，它驱动都要帮你把这些事情都解决掉。
那么当一家写驱动的公司的软件开发能力比较弱的时候，比如说个别的显卡，他们的表现可能就不太明妙了。然后当家公司的软件开发能力，驱动写得非常好，然后他们的表现就会非常棒，你会觉得然后这个时候对于用户的感觉就好像，嗯，你这个设备就不太行，这个设备就可以。我不同的同一个游戏，我在这个显卡上明明你的算力更强，但是好像我跑起来会更慢，大概就是这种原因。然后我们的现在的 h i 这个东西，就是说驱动层会做得非常的薄，驱动只做最核心的事情，然后就会依赖于你的开发人员需要，你对这个你的程序是非常清楚的，你想要干什么？你这个，你这张图，你比如说你画了一张图出来，这张图后面你是否会需要再被复用？你这张图后面会是怎么样？然后你这张图是不是画好了之后直接画到屏幕上去？你都是得清楚这个事情，包括我们的那个更新机制，然后再包括你这个东西是否要多线程同步还是什么的，这些都是需要那个开发人员是知道就知道了，非常清楚你们的各种依赖关系，也都是需要开发资源的依赖关系，然后包括你的那个资源分配，嗯，OK。这个讲的资源分配的话，这也是沃克和其他 12 需要一个做的事情。
你在写D3、 D11 或者 OPEN 9 时候可能是永远没有思考过，当我去开就是，嗯，开辟一块纹理的时候，我还要去思考这个纹理的内存是怎么管的。一般来说我就直接开起来申请一块空间，就像 new 的一块空间一样，OK，这样就可以了，但 work 它不行。 work 的一般操作是你首先要申请一个足够大的一块内存，然后你自己去分配这块内存的哪块区域给这张图，这块区域给另外一张图，OK，第三张区域给第三张图，OK，所以说 work 的话你需要去这种内存分配的事情，你也要自己去考虑，自己去管理。
当然这种东西是会有一些比较友好的第三方库，然后它对于多线程也是友好的，因为它的接口话就是基于 command buffer，就是一条所谓的 command buffer，其实就是把所有的 GPU 的命令我扔到了一个队列里面去，这个队列你再往里面塞的时候，那个 GPU 其实是并不知道的。然后等到我队列我都已经定义完了之后，我再去扔给GPU，它是通过这个方式，然后可以实现多线程的油耗。然后我们再回到回头看传统的 h i 的时候，因为有一个上下文的概念，有个状态机，那个时候我如果要实现那个多线程的话就会很麻烦。比如说 open go，我可能有三个线程，每个线程我都会需要绑定一个一个context，然后每个 context 之间他们资源的那个需要做共享，然后还需要，嗯，资源共享，然后每个 context 我还要去管理好他们的生命周期，美康 test 他们有一个自己的状态机维护，这个就会非常的不友好。
然后这两个区别的话是现代的 HI 驱动，其实等于说不帮，不会帮你干任何事情。然后是你要自己去理解你的程序是要干什么的，你才能够写出更好的东西。然后第二个是你如果用现在HI，你可以很容易的就写出高性能的，不是很容易写出高性能的程序，是你有能给他提供了一个你可以写出高性能程序的能力，但是你要真的写出那个高新能力，你是需要一个非常强的一个熟练的情况，你对你需要对你的硬件，包括你的程序运行的逻辑都非常了解，你才能够写出一个非常高性能的一个东西，所以说熟练的程序员你就可以体验那种掌握了一定的感觉。你可以充分调配你的那个 GPU 的硬件的资源。然后还有一个比较大的时间，就是说当你的程序卡在了 CPU 调用上面，而不是 GPU 上面的话，那么你用现在的 H i 的这个情况就可以非常好的提升。
我肯，我刚才提到的一个 command buffer 是能够复用的。这个什么意思？就是说有的时候我们每一帧画的东西其实是一模一样的，你 open 解耦的话，每帧你都会要去调用那些绘制的这些东西，每次都要重新重复去调用一遍那个 work 的 open 9 的命令，然后 work 的话你只要建好了那条可能buffer，你如果确定你后面的所有的调都一样的，那你就把那套卡片办法你复用就可以了。你每次都是把那卡片办法给扔进去，OK，然后我这边的话推荐的学习的曲线的话，我是不太推荐，直接上来就是你什么都没有学习过的话，就用 work 来学习。
我是或者 DX D12 我是不太推荐的，因为他们的概念太多了，你需要知道的事情就很多，特别是我可能初始化，这个你去理解一下，我觉得就挺费时间的，不像 open g o，你只需要有一个库，比如说 GOFW 或者什么之类的，你的上下文就直接建了。
这个我提一下 open g o 的上下文其实是也是每个平台是有一个自己的实现，你 Windows 上有个 Windows 上实现是WG，你手机上的是EGO，然后苹果上就是EAGO，然后什么 Linux 是Links，我有点不记得了，那个叫什么了。
对，然后所以说我觉得上手你们可能最好的选择是 open 9，因为它真的非常简单而且接口，而且上手特别容易快，特别快，你可以很容易的就写出你想要做的各种效果，这个只是学习的状态。当然你想的更深入的时候，你想要做一些效果更好的事情， open g o 其实就显得有点薄弱了。然后第二个是我想要推荐的是第三第十一，我是蛮推荐大家学习的时候是从第三第 11 的来入口，因为第三第十一它虽然说也是有个状态机的概念，但是它接口基本上都是基于 OP 的，然后所以说你对于它的那个绘制管线的理解起来会更容易，你直接看它接口你就知道了。
OK，我的绘制管线是长这样子的，不像 open 机油，每个都是状态机。嗯，曾经我在初学 open 节的时候，我的老师就有这样子一句我觉得非常有趣的话，就是说当你学习 open 节的时候，你去看欧文杰的教程，它还要实现这个功能，可能会按照那个欧文杰的函数一行行的写下来，你在你不太理解的时候你就一行一行的抄下来，不要觉得某一行是没有用的，然后把那一行把它关掉都是有用的。
嗯，这个我举个例子，最近我有个同事在做的一个工作，就是沃克转换成 open GL，就 Walking 的一个图片转换成 open GL，在手机上它的路径就是 Walking 转换成了一个叫 Hardware buffer，一个安卓的一个对象，然后再把 hello buffer 转换绑定到一个 open go 的对象。
这个听起来挺容易的，对吧？但是他就是一直在手机上，一直都画不上去，但他其实很奇怪，而且都画不上去，也不是所有手机都画不上去，是那个小米的手机是 OK 的，没画上去，但是华为的就不行。然后继续去查查了后来之后看了之后的结果是，他 OPEN 9 在创建纹理的时候就省掉了那个教程中的一些设置采样器的这一步，他就没有设置了，然后他觉得这个好像你设置或不设置总有个默认值吧？他会他觉得，但其实不是的，这个完全是看驱动的，华为的驱动就没给你设置默认值，那么你就画不上去了。但是那个安，那个小米的高通今天就帮你做这个事情，你就可以换上去了。
这个就是我说的，可能这个真正的实现很依赖于你的你的硬件设备，所以说当你要写 work 的时候，尽量按照标准的方式去实现，按照标准的那个流程实现，不要去省略一些东西。然后当你想要某种扩展的时候，你从硬件里面 query 出来说我肯支持这个功能扩展其实是不一定的，这个是要打个问号的，你需要一些别的手段来去验证它是否支持。这个问题在 open GL 中存在， work 中也是存在的。
OK，然后下面我来讲一下这个课程的主要的内容。第一个是初始化部分，然后第二个是渲染的主循环，然后最后渲染完了之后，我们要退出一个退出程序，这个是我们可以看到我们的作业，我们作业那个homework，一 homework 0 的我们绘制的一个三角形。OK，三角形，然后它里面其实也是这个就是我们的一个初始化，这个是我们的初始化设置窗口，然后创建资源的对象，这是我们的初始化的一个阶段，然后这个就是我们的主循环的阶段。OK，然后我们对应的代码部分是这样子的，然后后面我们初始化的话，首先就是要做三个东西的初始化，一个是创建窗口的话，我们一般来说会用那个 g o， f w 或者 SDO 之类的一种第三方库来做。嗯，我相信应该没有人会愿意用 win 32 的 native API 或者 Linux 的那个怎么找微 land 的，或者是 X11 去来创建窗口，那个太复杂了，然后OK。
第二个是我们要初始化work，其实是等于说以程序我要跟，首先我要去载入 work 的这个驱动这个库，然后第二个是我work，我要跟我的显示设备来取得联系，告诉我我这些命令得让哪个硬件设备来帮我渲染，然后最后我渲染完了，计算好了最后的结果我要呈现到屏幕上去。
这个就是我们第三步要创建一个叫 swipe chain 的一个对象，这 Swift chain 就可以让 work 跟显示的窗口取代联系，让我们最后的东西绘制在窗口上，这个是初始化的部分，OK，然后后面再是渲染的主循环渲染，我们要渲染我们可以把我们的渲染想象成一个函数，函数的输入是什么呢？几何信息，还有一些 UNICORN uniform，其实就是 CPU 端传给 GPU 的那个你的参数，我们的想要的，我们程序想要输出就是屏幕中显示的画面，然后我们的这个逻辑就是着色器，着色器就是，嗯，之前那个霍雨芝霍老师应该有简单的提过。
OK，然后我们的主循环大概就会有三个阶段，第一阶段是更新 CPU 端的业务逻辑，一般假如说大部分游戏可能就是游戏的业务逻辑，我们这边可能就非常简单，可能只是一些 UI 逻辑，或者一些鼠标，比如说控制相机之类的这种逻辑。第二个阶段就是你要把你的 CPU 更新好的数据拷贝到 GPU 中，OK，然后第三个阶段就是你要生成的你的卡门纳buffer，把你的渲染任务扔给GPU，然后让 GPU 在屏幕中显示出来，OK，然后后面最后当你这个主循环结束了，你想要退出程序，OK，然后把所有的资源释放，然后关闭你的程序窗口。这样子就结束了我们的整一个整个流水线，就像这个，我就跟我们可以对照着我们的 homework 一的 hello 全狗来对比一下这个流程。
然后首先是初始化我们的worker，第一个我们要用嗯，调用 API 来实现窗口这个地方，嗯，其实跟 open 9 不太一样的地方就是你的窗口类型我可能是需要知道的，比如说你的窗口是 win 32 建的还是 XCD 建的，还是微蓝的建的？还是 Mac 上的那个什么东西建的？因为我可能后续在创建 swap chain 的时候是需要这个信息，然后来选择对应的扩展才能建出我们想要的 swap chain。然后嗯，比较信息，好像现在就是 SDOGFW 这些一些窗口的三方库，可以很方便的获得这些信息，包括窗口的类型，然后包括那个怎么去建 up chain 什么之类的，它都可以帮你去实现好这些功能可以帮助你去初始化work。这个就像 GOFW 里面去初始化那个 open g o 的上下文一样，其实你真的去看起来它的 open g o 上下文创建的话，其实还挺复杂的。
然后OK，然后我们再来看一下我们的 work 的一个整体的一个概念。我们的 work 的话，我们先看我们这个右边这张图，有一个应用程序建了两个 work 实例，第一个 open 实例建了两个物理设备，第一个 workcd 建了两个物理设备OK，然后第一个物理设备有一个叫逻辑设备，然后第二个物理设备建了两个逻辑设备，然后每个逻辑设备有一些队列，然后我们的绘制命令只有 command buffer 是扔到了那个队列里面去了。
然后这个是一个相对来说非常复杂的一个 work 的使用情况，很多时候并没有那么复杂，很多时候我们只有一个实例，一个物理设备，一个逻辑设备，然后队列可能也只有一个或者是多个，但通常情况下其实一个大部分情况就是够用了。但是我们要回头想一下，我们 work 它在设计的时候为什么要设计的这么复杂？其实你想象也比较容易理解，就是说当我当你有四块4090，你想玩游戏的时候，就是我们以前说的四路泰坦，现在就是四路4090，你怎么去操控？让这款显卡干这部分的活，这款显卡干这个事情，让另外一个显卡干另外一个事情，让每个显卡都能够尽可能的去充分利用。
这个事情你怎么做到？ open 9，嗯，告诉你很困难，但是乌克你可以对应的物理设备，当你有四块四零九零的时候，其实一个实力能够 query 出 4 个物理设备，然后你这个实力可以去去选择这个物理设备。比如第一块显卡，第二个显卡，第三块显卡，第一块显卡只用来做物理模拟，我拿它物理模拟结果扔给了第二块物理设备，第二块物理设备纯粹做渲染的某一部分，然后第三块再去做某一些事情，然后最后在最后的一张显卡，那张显卡专门只做渲染，把那个渲染出来的结果给画上去。
OK，那么这个时候你所有的显卡都会有了，然后有人问为什么一个物理设备会出现多个逻辑的 work divorce？嗯，这个一个逻辑设备你可以想象成其实是对于一个一个队列的一个实例化，其实嗯，它其实是，或者说叫，嗯，我们真正我就是我们真正 API 其实传输给的是逻辑设备，并不是个物理设备。
所以说你的逻辑设备的时候他会去，嗯，后面我会提到他那个队列其实是有不同类型的，我这个逻辑设备的队列只用来计算图形管线，那么OK，我说的命令图形管线命令我得扔给他，我后面的队列假如说我只是用来计算那个肯德学的就是那个那个什么计算着测器，就类似于 CUDA 之类的这样子的一种东西，那么我所有的命令可以扔给他。但通常情况下我们并不需要去做这种事情，因为我们只需要有一个，我们只需要有一个这样的多个就可以了。
OK，也有问有多个 work 时间用处是啥呢？这个目前我也不是很清楚，因为我也没有遇到过。我需要多个实际的情况。大部分人来说，游戏场景或者那场景OK，我一个实例就足够了，不需要那么多的实力了，所以说我们只需要考虑这种情况就可以了。但是沃克呢？我们要明确知道 working 的，它是设计可以让你来做这种事情。
然后，噢，有个说那个一个逻辑设备，有一个逻辑设备不是可以有多个队列吗？对，这是可以有多个队列，但是每个队列它会有它的功能的限制，不是所有的功能都可以在所有队列里面去运行，队列跟队列其实是不一样的。这个我下面的 PPT 会讲，然后，OK，我们再来初始化沃克，然后初始化沃克这个会有一个比较共比较重要的概念叫layer，就是层我们一个application，然后我们要去载入 work 的库，会有个 loader 的过程，然后这个 loader 过程不是直接载到那个驱动了，而是要一层 layer 然后宰下来，然后最后再到驱动层。
然后，嗯，所以说我们见到沃克 instance 这个东西，其实是初始化沃克库跟我们的程序之间沟通的一个桥梁，然后我们需要指定的一个，通常我们需要指定的是 Swift chain 的一个类型，这是个扩展。有些时候其实你的 work 是一个离线渲染的功能，其实你就不需要这个功能了。然后第二个，比如说你有些扩展，你想要去做调试，你想要给每个沃克起一个大家能懂的一个名字，比如说他叫纹理衣，这个人纹理叫颜色纹理，另外一张名义叫什么法线贴图。当我想要给他们设置这种功能的时候，我们就需要开启一个可调试的一层。
然后最后是，比如说我检查我的 work 调用错误了，在 open 机油下面就非常麻烦，只会能通过一个GOL，然后去猜你可能调了什么错误，那我可能它会有一个错误调用的回调，然后这个回调函数也不是沃克的核心驱动中的一部分，它也是一个外置的一个检查了层。OK，然后这个地方，比如说我们可以看到我可能将很多功能拆到了不同的层里面了。然后我这边下面举了两个例子，一个是用于检查错误的一层，它的它名字叫这个。然后第二个是 RENT Docker，它是一个 work 的一个 GPU 的调试工具，它不光能调试 work 了，它的第3D、 open g o 它都是可以调试的，然后这个是它自己做的一个层的名字，那么换句话说，其实我们每个程序你如果可以的话，你都可以自定义一个自己的一层layer，然后把那个 layer 让你的 work 程序跑起来。然后这边是我们的相关的 API 跟那个作业代码，后面可以大家如果课后大家有兴趣的话，可以去关注一下沃克的这些 API 跟它的命令。
OK，然后我们刚才说了陈，那么这个陈到底是干什么的？嗯，我们的讲要初始化 work 有一个函数，比如说我们这边要读那个 function a，b，c，d，e，那么 layer a 它是重写了a、b、 c 三函数。 layer b 它是重写了CD， e 三函数。然后最后我们的接口肯定也是有a，b，c，d， e 这这 5 个函数，那他的意思是当我 load 我去调用了 work function a 的时候，我举个我还是取c，他调用了 work 方选 seed 时候他会首先调用 layer a 的方形c，然后类 AA 的方形c。它的陈述结束之后，它会去调用类叶 b 的方形c，然后再去调用类叶最后真正的接口的那个方圆c。换句话说，其实我们可以把这个 layer 当做函数重载来理解，它其实是提供了一个函数重载的一个方式，或者叫hook。
对， open 9 的 hook 会很麻烦，对吧？然后我很OK，你们都喜欢hook，好，我提供一个官方的方式让你们去hook，这样子你们所有调试工具，你们就可以很自由自在的去 hook 了。你们调用的所有的 MINI work MINI 都可以记录下来，你们自己想做任何检查都可以了。
以前在沃本机油调试的时候经常喜欢干这个事情，把你所有的 open 机油的命令给它，把它打印出来，包括时间，线程什么之类的。这个时候如果你有兴趣，你就可以自己建一个自己的layer，然后把所有的 open 九的命令把它 hook 做，根据线程，根据时间戳，然后把所有的 work 的调用给打印出来。
当然官方是有提供这样的一个一个一种方方一个方法，这个就沃克的一个雷爷的一个概念，OK，然后下面我们沃克恩的instance，我们已经跟沃克恩的驱动取得联系了，后面我们就要跟那个显卡，我们真正的硬件设备取得连线。这个时候 work 它需要有一个去 query 出我们硬件设备的一个功能，然后work，它可以去拍出我们硬件设备的名字，你这是什么显卡？什么显卡？然后你的能力是能干嘛？然后比如说我的电脑是两块显卡，一块是 AMD 的显卡，一块是英伟达的显卡。OK，那么我现在直接运行一下，再把它做掉。
好，这个时候我们 query 出了我们的第一个显卡，这个就是我们显第一个显卡的名字，一张 3070 的显卡。然后这个李密斯这个对象就是它的所有的限制，它有多少张？它图片的分辨率最多是多少？或者是所有的德泰斯的输出是多少，这个每个的限制一般来说会不太一样。然后官方会有一个，就是会要求你的驱动支持的最低，就是最低的限制是多少，不过这个最低限制也话说过来，也是看驱动实现的，不是每个驱动都老老实实的按照这个 GT 限制来做，有一些它声称它实现了，其实并没有。这个不对了，再跑一下，然后我们再去 query 出我们的第二张显卡。
好，我们 query 出了我们第二张显卡，加大显卡是 MD 的一张核心显卡，如果你仔细去对比的这个限制的话，你会应该可以看到它这个限制是会比那张独立显卡会小很多，也就是说它的能力会更弱。然后我们在程序的提供的时候，我们要根据我们的能力，然后选择合适的显卡。当然我们在做游戏的时候通常会喜欢去调用那张独立显卡，但也并不是所有的都是想要调用独立显卡的，比如说我的程序比较轻量级，为了节约能耗我可能就无所谓，我可以选择一个我的核心显卡也是可以的。然后刚才有一个有同学就问，有同学去问那个这个队列明明我一个实际化也能有很多队列，那么为什么我还需要有这种有不同的那个逻辑的？是因为队列的那个它会有一个簇，它那个或者叫做 quick family，这个处它会它的能力是不一样的。然后每个队列处只能允许部分的结果的操作，比如说它可以实现那个渲染功能，实现计算折射器相关的功能，它这个可以支持复制buffer，就做拷贝的这个功能。
然后并不是每一个队列都能够实现所有的功能，有些队列只能实现部分，有些队列可能是另外一部分，有些队列是另外一部分，也有可能它这个硬件实现就没有一个队列能够实现所有的部门。这个时候你就需要根据这个队列不同，然后来做这个操作。然后包括你的那个 swipe buffer，就是你绘制的东西画到屏幕上去，也需要那个对，就队列处来实现这个它能够支持的功能，你才能够用那把这个命令扔到那个队列处的那个队列里面去。OK，然后我们这边可以看一下我们的队列处。
OK，我们看一下，我们当我们去获取一下我们的队列处，可以在我的电脑上是有三个队列处，然后这个 flag 就是表示他们的能力151214，这个也是依赖于这个是一个枚举变量，这个我就不去课上就不去仔细去看是为啥了。然后每个队列的数量是多少？okay。
然后在后面就是我们要做的那个逻辑设备，就是 VK divorce，这个我们有了物理设备之后，我们的程序需要跟物理设备打交道，这个时候我们就需要有一个逻辑设备，然后来跟我们的物体设备去打交道。嗯，然后我们有一些在我们在创建这个逻辑设备的时候，我们可以去做开关，比如说你我们的程序并不需要几个组织器或者细分组织器，或者某些压缩纹理的时候，我们就可以把这些开关把它关掉。然后当我的程序必须要用几何锁设计才能实现，然后我们去可以去 query 出我们的物理设备能不能支持的功能。OK，它不支持，那这个时候我们数字化就可以结束了，因为它无法执行我们的程序。然后后面如果我们成功建设好了逻辑设备之后，就可以从逻辑设备中去获得我们的命令队列，就是quick，然后这个 min 队列其实是我们的队列处中的一条队列。OK，然后我们建好逻辑设备之后，我们整一个沃克的初始化就完成了。
下面是要跟我们的沃克跟我们的屏幕去做交流，这个东西就是，嗯，它其实是个扩展，我们可以看到沃克跟我们的屏幕的那个交流是个扩展，并不属于沃克核心的一部分，这个也很好理解，因为我们的，因为我们的那个核心的那个就是我们核心渲染并不属于核心渲染一部分。然后我们不同平台它的不同的肯定是需要有一个不同的渲染方式。 Windows index，每个平台都会有渲染方案，所以他们给 working 提供了一个扩展。比如说我们在 Windows 上面用的就是 win 32 的surface，需要这个扩展来实现，然后包括我们建 store train 这个事情其实也是 work 的一个扩展，因为 work 其实并不需要，沃克并不需要一个输出，对沃克来说，他只是说我渲染到一张图里面去就可以了，我并不需要输出这个到所有人线上，然后基于所有线里面，然后所以说它一般也是一个沃克的一个扩展。
嗯，然后我们需要查询的那个队列处，我们刚才我们提到队列处有，我们可能刚才已经选择了一个队列处去创建了我们逻辑设备，然后这时候我们去验证一下我们这里的那个逻辑设备选择队列处是否支持这个surface，如果不支持，那么你就要去另外去重新选择一个队列数。
如果恰好你所有的功能并不存在，那么一个队列处的情况下，假如说运气非常不好，它的 Swift Chin 的那个队列处需要额外建一个device，那么你的 queen 就得扔到另外一个 divorce 里面去做了。但比较幸运的是一般来说应该没有这种驱动。然后我们在创建我们的所有线的时候就需要定义，一般的时候是需要定义这样的东西，比如说颜色空间，你是 SR g b 的还是 HDR 的？然后你的刷新模式是同步的还是垂直同，有没有开垂直同步还是不开垂同步？当然 work 里面它并不是简单的是否开垂同步，它里面有还是有些别的概念的，这个可以，有兴趣可以再去看一下，可以自己去观察查阅一下 work 的那个手册。
然后还有一个是缓冲的数量，你的是双缓存还是三缓存？然后这个双缓存三缓存这个概念的话应该，嗯，我不知道，霍老师应该有提过吧？对，然后最后我们要从那个左右群里面去找到那个 work 的image，就缓冲的那个对应的那个image，然后用于后面的去创建那个 frame buffer，然后去绘制到我们的 Swift 上。所以我们的我们如何绘制到 Swift in 上？就是把它划到 Swift in 的那个 image 上面，作为我们的 pass 的一个输出， OK 了。嗯，刚才有人同学问到移动端设备支持的特性少吗？那么这个是肯定的，移动端的设备支持特性一般来说是要比 PC 要少一点的，至少移动端的 retracing 基本上可能最新的一部分手机是有的，大部分手机还是不支持的，对吧？
然后 c l m S 5 的绘制主循环OK，然后我们在提到绘制主循环的时候，这个可能会。嗯，跟 OPEN 9 可能不太一样的一个地方，就是你需要知道你这个会议室循环的所有的功能，所有的能力，它是没有一个传说中的一个默认值，这么一个东西，其实不存在的，所有的属性、所有的参数都需要你去设置过一遍。
只不过说你这个功能可以开，可以关，但是你都要去显示的去说你要开还是显示的要关，这样子像欧本杰的话它OK，它其实是有一些默认指性的，比如说我深度检测，我要不要检测，对吧？所以然后一般情况下我们就是通过绘制管线，把那我们刚才说到的我们几何信息贴图，把它画到屏幕上去。然后我这里会讲到的是我们一般情况下最核心的一个灰阻管线，然后这边就没有 mash 歇的几何细分，这些不太常用的功能就不在这个我们的课程里面了。当然当你学会了绘制管线之后，你后面的那几个细分你去继续自学一下，其实也是非常容易的，也是非常有趣的一个事情。特别是 match 系的，我觉得这个是一个挺有趣的一个功能。然后最后是讲到不同的i，全i，其实我们刚才讲的不同平台大概第三、第十一、 open 9、沃肯，还有苹果的mental，其实他们细节上可能会有一些出入，可能有些命令它这边是没有的，但它那边是有的，但是整体逻辑是一样的，比如说这个，比如说后面再说OK。
然后第一个阶段就是我们的顶点输入，我们需要有一个叫做顶点数据缓存，电数据缓存就是缓存了，你的，OK，有同学说是不是可以在 pipeline 中定义自定义阻塞器流程长短？是的，所有的那个你的流拍板流程都是你自己来定义的，你可以不去加那些你不想要的流程。
然后比如说我们现在画个三角形，我们是需要有个三角形的空间位置，那样现在的发现如果我要给他上纹理的话，需要一张纹理坐标，然后可能还有一些别的属性，比如说顶点颜色之类的一些别的属性，这些属性我们要把它扔到一张停点缓存中去。然后这个我就举个例子，我们把那个我们这边通过两块缓存，一块缓存只存储顶点的坐标，另外一块缓存了顶点的防线，然后一块缓存，缓存的是纹理跟其他的顶点属性缓存在一个八法 0 里面，然后八法一是缓存了顶点坐标顶点，发现为什么要这样做？是因为我们的这个逻辑可能是我们顶点坐标跟顶点法线可能会实时变化，这个实时变化的原因可能有多种多样，可能是由于可能，也可能是由于那个自定义的嗯，功能，比如说你想要计算某些蒙皮动画的一种功能的时候，就可能需要你的八法一，就是要每帧去更新它，这个时候我们把 buffer 一跟八法零放在一起就显得不合适了。
然后第二个是顶点缓存的这个排布了，跟我们的马泰斯的 input 会有一定的性能影响，这个时候我们也有一个这样的一个优化的算法库，叫Mesh，那个就会有个这样的算法库，可以大家去用。然后，嗯，对，然后第二个是所有索引的顶点，比如说我们的画三角形，然后它三个顶点分别是它的索引有索引0，索引一、索引2，然后对应到过去就是说我一个顶点的复用的一个关系。我这个顶点在这个三角形中是这个顶点，在另外三角形中其实它也是个顶点，是相同的顶点，那么这个时候我就没有必要把那个顶点缓存里面再去产生一份了。
然后我们在索引的时候我们会发现三个索引指向，三个顶点，这个时候会有一个比较常见的优化，就是说你那个索引指向的顶点的位置在那块顶点属性分配中不能隔得太远。比如说我这边举的就是个不太好的例子。诶，这个好像打错了，这个不是属于，这是顶点属性。OK，我们的三角形前三个顶点分别指向了第一个顶点跟第三个顶点跟它最后一个顶点，这个就非常不好的例子了，是因为我们在大家学过计算机硬件的时候，知道有个叫缓存的概念，然后 GPU 其实也是有缓存的这概念的，所以说它这个顶点属性会偏了非常远。你的三个顶点属性如果隔得非常远，就会造成 cache miss，然后一旦有 cache miss 就会引发那个IO，就是 IO 的一些性能损耗，这个性能损耗其实相对于计算的那个代价来说，这个性能损耗远远大于计算代价，所以我们在写 work 的时候，这个一定要考虑到是你的 cash miss 这个事情。一般来说它的影响远远会大于你的什么计算复杂度之类带来的影响，这也是一个等于说工程的一个工程经验。
OK，然后第三个是你的图源拓扑类型，就是说你画的是顶点还是线，还是画三角形，这个我们可以看一下，我可以这边有个例子，我们的 homework 一。对这个就是我们的课第一个课时的一个作业，它需要画这个是画面的方式，然后这个就是画线的方式。来绘制不同的效果。
OK，最后会有一个叫，我们这边叫其实是有四种叫跑，然后当你有索引，你只有点点数据的时候，你就用叫你可以 command job 就可以了。当你有了顶点索引缓存的时候，就需要画index，然后后面对应的有两种叫做 in direct，叫渐渐的会者是什么意思？就是说我们在画这个 Mash 的顶点有多少个的时候，其实我们在 CPU 端我们通常是知道的，比如说我这个兔子有多少个顶点我是知道的，所以我 CPU 端我就可以直接把那个函数调用的时候，把这个参数给写进去了。
但是有些时候我是不知道的，比如说这个 Mesh 是通过一些物理模拟也好，或者深层的方式也好，或者怎么样也好，它是 GPU 计算出来的，这个 Mesh GPU 把有些我看不见的东西把它踢掉了，那么这个时候我就不知道它我需要花多少个顶点了。那么这个 injector 就是会把那些前面的这两个函数的参数作为一个 GPU buffer 传给GPU，通过这种方式它又有对应的另外两个进阶的绘制的方式，OK，然后下面一个阶段，OK，时间好像有点太来得及了，那我后面讲快一点。下面这个方式就是一个 v 泰歇德，就是我们说的着色器。
然后 v 泰歇德，我们一般来说沃克提供了很多的编辑方式， HOSL 或者 GLSL GOSO 是 open GO 的那个协作语言， HOSL 是那个第三第 11 的变成方式语言。然后编译器我们大概常用的有三种，一个是 DX shed compel，有些人同学问这个明明是地差的，现在变形能变异 work 吗？其实是可以的，而且还表现的还挺好。这些编译器都可以在那个最新的沃斯柯 SDK 里面去找到。还有一个是GOSLC， GOSL Alarm，大家可以选择自己觉得方便的编译器，然后去写对应的shader。
当然我个人是比较喜欢写 HVCO 的，可能我是觉得，嗯，只要可能是欧芬杰，我伤了我表深。对，然后然后顶点着热气，我们在现在生成了之后，然后第二个是要它的主要的功能是干什么呢？我们的几何的信息经过顶点着色器计算，然后画到屏幕上去，然后经过旋转变换透视。什么旋转变换到屏幕上去？这个需要提一点是沃克的一个坑，沃克的 NDC 空间就是它的屏幕空间，就是看我左边的图这个地方它跟别的不太一样。我们一般的这种屏幕空间是x，横的是 x 轴， print 扩展好像是没有的，目前至少我不知道鞋的怎么开 print 扩展，有同学问这个，有同学问谢德里怎么开 print 扩展？嗯，我并不知道这个怎么开，然后应该是不行的。然后我们通常蝎子里面要调试，一般来说是把它作为一个颜色作为输出，很少会直接打印的。然后你我们在画那个三个轴的时候，我们看到它的 x 轴还是横向的，OK，没问题。然后 y 轴是朝下的， a 轴是朝前的，这个它因为它是跟 OPEN 9 一样，它是一个右手坐标系，所以它必须得是个右手坐标系的前提。
但是他又想要 z 走沿的正方向，这个是，这个是因为我们的裁剪空间一般来说是 0- 1，然后欧本机油的那种实现 z 延的负的方向其实是一个我觉得是有点蹩脚的一种方式，它会把你的踩水空间先 4 到 - 1 到1，然后 - 1 到1，再把它映射成 0 到1。这个听起来感觉好像唉，我好像也没有什么问题，我 - 1 到 1 映射到 0- 1 好像没有什么任何偏差。
其实不是的，因为计算机的计幅点数计算是有精度要求的。对，然后我们在离邻比较近的那个地方，其实你的有效位就小数点有效位其实会更，就是你的有效精度会更多，我们的有效未长度是一样的吗？你在离 0 比较近的时候，有效进度会更多，为什么呢？是因为你的 0 前面都是 0. 00000，这些都不是有效尾，但是当你离得一比较近的时候，其实你的有效进度就弱了，为什么呢？是因为你的那个金值是 0. 99999，从第一个 0. 9 开始，它的有效位就开始算了。
对，所以说我们一般来说有个精度最好的算法就是叫 reverse z，就是离你越远的那个深度是0，离你最近的那个是1。这个有兴趣大家可以去搜索一下。可以，然后再是工商化的部分，工商部分就是它有需要你定义这些功能填充方式，就是你是三角形，不是 10 的填充，还是只是填充一个空的？噢，刚刚我那个举错例子了，那个 GOTF 的这个应该是个填充方式的问题，不是那个绘制的，它只是是否填充任务，应该只是一个，是否填充应该是通过填充方式来实现这个功能。
刚才我有，刚才我讲错了，OK，然后还有一个剔除方式，我要把正面跟背面剔除，毕竟背面我可能看不见，我就不要画它了。然后还有正方向，我们是那个顺时针是正方向还是逆时针是正方向？这个也跟 open go 有个它蹩脚的 NTC 有关系，在同样的数据，你在 open go 里面可能是个顺时针的，但你在 work 下面可能就变成了逆时针。
我在上课，稍微等我几分钟，OK，然后后面是我们的视图，我们要绘制我们的那个视图区域，然后我们的窗口跟我们的视图，你会发现仕途就是我真正绘制的那块区域。然后窗口就是我们那个，比如说我们画大屏幕，然后仕途区域比窗口小，这个我们大家很容易理解，就是很多时候我们只想要画窗口的一小部分作为某一个控件，这样子画就可以了。然后但是有的时候我们的视图会比窗口大很多，这个什么样的情况会有？比如说我们现在这个场景里面，我想要把中间这块地方抠出来是个 1080 T 的一个个区域，那么我就可以把这个视图拉到足够大，将那个窗口的位置恰好在视图的这块区域，然后恰好是，我估计还有 20 分钟， 1420 分钟， 20 分钟已经没有其他，当时我们不是。OK，然后这个就通过这种方式会需要来一个这样的功能。然后我们的CSM，有些 CSM 的实现，你可以看他们的实现代码，可能就是通过这种方式来实现了，把一块局部的区域的分辨率给它提高。
OK，然后最后，然后还有一个剔除方式，这个剔除方式大部分情况下是，嗯，不太会用到的，但是我们的 UI 可能会用的比较多。比如说我们在左边两个会看到一个开启的，一个关闭的，这个可能大家看的不是特别明显，就是在这个区域，大家可以观察一下在这个区域，的一个效果的一个差异。
然后再是 fragment 写的， frame 写的是一个渲染管线最核心的一个部分，大家所有的计算都会在这个地方，然后包括我们的纹理，一般就是用于纹理，有的大部分是用于颜色，然后有的时候会用于数据的编码或者是干嘛的。然后沃泰克斯学的顶点属性，我们刚才说了，它计算了好了顶点属性之后，它会经过一个星星差值到我们的 flag 那些的，然后你也可以选择不进行性踏实。然后还有一个缓冲区，缓冲区的话有一个，缓冲区的话有一个 unicorn buffer，然后或者叫 storage buffer，分别叫什么？ CT 430、 STD 140，这个 std 幺几零其实是指的是 open 企业的版本，其实然后还有一个叫 push constant，这个是沃克一个特有的一个一种缓存区，这个东西你就是可以你每帧都去更新的，每帧都去更新频繁更新的数据，你可以放到这个 push constant 里面去。
然后后面最后面是我们要注意一个事情，是在移动端上面我们要注意这个浮点数的精度，我们一般来说是，嗯，作为颜色计算， 16 位精度是完全够用了，但是作为顶点位子计算，经典位置计算的时候就需要一个 32 位的负点数，然后才足够用。颜色可能我们都知道颜色一般是 r 7、 D a 8，可能8位都够用了，所以我们在移动端上我们要非常注意到这个事情，你一定要优先把所有的浮点数都改成半精度的 16 位，然后再想要哪些可能不够，你再把它改成 32 位，这样就可以了。OK，然后最后是 frame buffer 输出，我们的那个 fragment 说那个 fragment buffer，然后 fragment 写的我们的输出之后会算出一个颜色到那个，到那个 fragment buffer 里面去，然后 fragment buffer 里面会做两个事情，一个是混合，是你的输出的颜色跟原有的那个颜色去做一个混合，然后我们的或者阿尔法混合之类的这些功能。
然后还有一个是深度检测，还有一个是模板剔除检测，然后这个有一个要提到的是我们深度检测一般来说是要做的事情是，比如说我近就是，嗯，画家算法离得近会把远的给挡住，这种检测干的就这个事情，然后那个模板检测大概嗯，我这里就不举例子了，大家如果后面遇到的话就会用到。
嗯，然后我们这边那个深度检测，我们这个东西其实是一般的现在的现代驱动都会做一个 early z 这一个操作，就是说在你的 frame 的 sheet 里面不做 discard 或者不去修改深度，那么我这深度其实在 vtext sheet 出来的时候我就已经知道了，那么这个时候当我的深度检测一定会失败的时候，那么这个像素就不会画了。然后这种东西的话大家可以讲一下，如果这种东西就会有一个可以天然想到一个优化我们的，嗯，一个优化叫做 Pre depth，就是我在会议之前我先把深度先写一遍，一个 flame 那些的什么都不干，就我特写的把深度给写到那个屏幕上去，然后我后面我再去做真正的绘制，那么我就可以提前把那个深度一定过不了的那些东西把它剔除掉了。
那么但是这种方式大家是一个 PC 端常见的优化方式。大家，但是我要讲个，但是移动端这个方式其实是没有意义的，因为移动端的硬件结构是 Telebase render，然后在这种绘制方式下面，它可以先你先把所有的 GPU 命令先堆到那个地方去，他会去做那个Predips，它会把你所有的交号命令累积到一定程度。然后说我这些你的所有交号里面去计算你的深度，然后远的我就把它踢掉，然后会被踢掉就被踢掉，然后会真正被绘制再去绘制。但是我们 PC 端的一般的，嗯，线下实验可能就不会做这样的事情。然后这里就要提到，我们可以想象一下，在 tell base rendolly 的时候，我们的半透就你开了 Blend test 就是 test Blend，或者你在你的 flame 下的做了深度的修改discard，那么这种 Mesh 的绘制我永远没有办法去提前把它踢掉，因为我永远不知道你的深度检测会不会成功还是失败，因为你在线索里面会改。
这个就是在移动端上尽量不要去绘制这两种类型的东西，一些优化。然后这里有个很有趣的优化，就是我们在画UI， UI 的时候一般来说是有个半透要抠一个形状，比如说有个兔子，旁边这个图是个方方的，中间有个兔子，这个兔子是个UI，但是我们在一种优化就是我去提前生成这个兔子这个边框的那个三角面片，去抠一个这个兔子出来。就是不是一个方方的一个三角面片，而是把这个兔子的轮廓给抠出来。那么这样子你会发现它在移动端的绘制会更高效一点，虽然说它的逆篇数更多。
OK，这可是我们的官商化的一般的绘制的流程，然后我在 PPT 中也会提到他那个沃克对应的那个对象。OK，我们再回到沃克，我们的沃克在我们的绘制管线里面，它有个重要概念叫runpass，我们刚才提到的这整一个绘制是一次 job call，然后沃克的话它的一个 RENT pass 里面是它的一个最小的一个绘制的单元，它会有可以有多次交考。然后我们的，比如说我从左到右讲，我们第一个 red pass beginning，它可以去定义你的那个福音buffer，就是我们的输出的纹理是什么，然后你的，然后第二个是绑定你的 vtext 跟 index 的buffer，就是我们的 vtext input 去定义你的输入那块buffer，然后我们的这个 buffer 是需要有个堆，你自己去管理堆去创建内存，然后去使用。
然后你在可能 buffer 里面去设置你的 view point，然后最后面，然后是要绑定你的pipeline，这个 pipeline 是一个，嗯，我可能不同于传统那个飞书管线的地方，然后就像之前有，嗯，有同学问到就是，嗯。我很是不是可以自己定义那个绘制流水，嗯，其实可以的，因为你在拍板案里面的歇德你不去绑，那么这个流程就不会去走，你拍板那里里面只去绑那个维泰 shit 跟 fragment shed，那么 OK 他就只会走这两个检查流程。然后我们刚才提到的那个工商化部分，包括 fragment 现在的深度检测， stand so 检测什么之类的，这些都是定义在 pipeline 中的，然后所以说 pipeline 是定义的整一个绘制流程的基本的东西。
然后在 open 结构下面，其实你是要一个阶段，一个你这个状态机要一个属性的去设，然后第三第 11 的话，它大概是抽象了三四个对象，你要去一个三四个对象去绑，OK，有同学问 subpass 是做什么的？这个我会在第三节课来讲，这个是主要也是针对于移动端的一个优化的一个功能。然后我们要绑定 describe set，这个就是我们传给歇德的 unicorn 就是传给歇德的那个参数，包括采样器，纹理还有buffer。
OK，然后我们 describe set 也是需要我们自己去管理，它有个 describe 的一个词，然后最后我们交靠结束之后我们再让它 pass and OK，那么有同学就要问了，我这个 rent pass，我定义两个 rent pass，那么我在 rent pass 这个作用于外面我能干什么呢？OK， rent pass 作用于外面你可以更新你想要的属性，这个属性我们在 runpass 里面是不能更新的，比如说你，我想要把 CPU 的数据传给 g p u，这个操作你是不能在 runpass 里面做的，你只能在 runpass 外面做。所以我们下面这个就提了一个简单的一个串行的绘渲染绘制流程。
我在 run 的pass，我在绘制第一个 run pass 之前，我先把 run pass 0 的所有的更新掉，所需要的 GPU 更新掉，然后有的绘制 run pass 0，然后我再绘制第二个 run pass 一的时候，我再更新 run pass 一的所有的结果，然后以此类推，直到所有 run pass 绘制完了，然后全部一股脑的扔给GPU。然后 Runner pass 是一个图形绘制的一个最小单元了，然后这个它定义了绘制的输出，这个我要着重讲一下它的那个福林巴菲的输出，然后它是定义了一个 IO 操作，就是说我在 begin run pass 之前，我的那个 run 的 target 就是我那个输出的那个图，或者叫 frame buffer。不同的东西可能这个名字不一样，我这边有些叫 run target，有些地方叫 frame buffer，其实指的都是同一个东西。
然后我的那个 frame buffer，我是否要把它的图片里面原有的那个像素里面的值要保存下来？还是说我并不需要管它？还是说我要把它清理掉，然后我绘制完了之后，我的这个东西我要不要把它写回到内存里面去？这个操作在 work 下面你是需要你显示的去定义好这个事情的，然后这个事情在 open 机油里面的时候，驱动会帮你干，驱动觉得你最后画到屏幕上去的时候，你这个图我没人用了，OK，我会给你用用那个 dont care。假如说你后面掉了一次克里尔卡拉的颜色，那么 k 我会把你定义成那个克里尔的那个颜色。这样，当时这是我的猜测，因为我也没有看过那个 open 机油的驱动的实现。然后大家可能会对于这种为什么我要定义这个这么复杂的东西，可能会有一些疑问，我再给解释一下。
比如说第一种，我们在读操作里面为什么要选择这个load？比如说我之前已经画好了这个模型，都画好了，画了张图里面去了，这时候我要再画个背景，这个画背景是一个新的乱的pass，那么我这个模型里面的那个深度，包括颜色我是否都是需要的，对吧？这我需要保持这些原来那个人物的那个模型的那个颜色，在那个图里面，这是要 load 的这种情况。
然后什么时候是中的 care 呢？我有一个 pass 专门做一个，比如说高斯模糊，那我高斯模糊是一个全屏的一个操作，那么，这个全屏的一个操作，那么这个时候它的输出我就可以不需要知道它原来的图里面是什么了。然后 clear 什么时候是 clear 呢？我的 pass 里面比如也是画模型，画模型并不是一个全屏的操作，我的背景其实需要一个背景颜色，这个时候我需要把它设成clear，这种情况通常来说深度图一般是需要的，因为深度图通常我们需要设置成一个最远的值，一般来说是一，然后我们再去画深度的时候再去做深度的比较。这里我回答一些同学的问题，一个是 pass 是不是可以一步也可以串行的？是的，这个是确实是可以一步也可以串行的。然后，嗯，这个是否异步串行这个事情，因为我是一个入门的教程，可能只会提到那个串行的。
后面第三节课我会讲到异步的情况，下面你这个 pass 该该怎么去设计它？OK，然后我们渲染好了之后，我们让它给它的时候也可以选择是否要stop，就是写回去或者是 dont care。然后我们什么时候是需要 store 的？比如说我们画完了这个图，我们画到写到屏幕上去。这个时候我觉得大家可能会有疑问，我明明我的绘制就是为了绘制到屏幕，绘出一张图出来，那么我为什么明明已经绘制了，我还需要把它扔掉呢？假如说我绘制的东西扔到屏幕上去，那么这张图的颜色的那张图我其实是需要的，对吧？但是深度那张图我可能就不需要了，因为深度我只是用来做，做深度检测。我才是，我才，我需要做深度检测，我才需要它。我不做深度检测，其实我是不需要它的。那么我把它最后画到屏幕上的这个 render pass，我就不需要那深度图了。OK，那我之前的深度我用完了，做完深度检测了之后，我就可以把它给 dont care 掉，就是我不要它里面的数据了。
然后这个操作大家会觉得比较复杂，但是在移动端上这个其实是蛮重要的。这个我也想举个例子，就是我们同样的 work 的程序，在小米手机上就跑的挺快的，但是在华为手机上就挺慢的，大概差一个数量级 6 帧跟 60 帧的区别，为什么呢？是因为我们的那个沃克用了非常保守的一些方式，就是在没有优化前用非常保守的方式都选择了 load 跟stop。那么华为的驱动可能就没有管你这个是否合理了，他就按照你写的来直接来运行了。小米的那个可能就按照就高通手机可能就会发现它也它的驱动可能做的比较厚，就会觉得你这个事情可能后面没有用到，它就给你踢掉了。
OK，有同学问什么提交到不同队列才是一步？不是都是一步，一步是指中的命令相对这个异步同步的话，其实是你在一条 command buffer 里面的所有命令肯定都是同步的，你的不同的 command buffer 中间才会有那个异步的这种事情。
OK，那么我们第一课时就讲完了，我们这第一课时主要是讲的我们一个沃克的绘制流程，主要的就是非常高的上面去看一下大概是怎么样的一个流程，我们需要对它的一个概念的一个理解。然后后面在第二节课我会详细的讲一讲，对于 work 的这个实际你要去绘制它，怎么去更新，怎么创建对象，这还包括它内存管理，然后调试，就是实际上手写的一个课程。然后包括大家比较那个关心的多线程同步这个事情会在第三课时来讲。然后后面是一些参考资料，这个我是非常推荐，大家可以买一买这本书，我很应用开发指南，这本书虽然说写的有点老，但是也不写得有点老，它有些功能其实并没有在里面写。比如说像麦西西的rechick，这个当时可能他在成熟的时候还并没有这些功能，所以他没有写，但是他有一些基本的那个功，就是基本的绘制功能都在这里面。
OK，然后后面是几个我觉得还是不错的 render doc 里面的有几些命令，然后还有一个是 work 的 reference 的文档，还有 work 的白皮书，这些我觉得都是不错的。然后还有一个我觉得还可以的一个中文教材，就写的比较，英文名字，应该就这个是下面的，有时候同学问这个本书的英文名字叫啥？就叫 welcome program guide，就叫 welcome 编程指南。
然后最后我也提供了一些 work 的实例代码。为什么会提供？因为我觉得你在学习一个东西，其实最好的方式不是看教程，也不是看别人的课或者视频之类的，而是去看代码，去看别人写的设计代码。我可能还是有一些不错的设计代码，然后他这个第一个的示例代码就是我们的课程用到的示例代码框架，我们选它也是因为它是基于 API 来做的这个示例代码， API 做的示例代码，然后它会有一个，就是当你想要实现某一个功能的时候，你就可以去找找它里面可能就会有这样的功能。比如说你想要找个 MSAA 的功能，它可能就会有个 MSAA 的事例，你如果你想找一个 conversation 的或者 Mesh 写的那个 c 代码，或者 rechasing c 代码，你就可以去找 rechasing 的 c 代码。
然后第三个我们是一个是 film 特谷歌的一个开源的一个渲染框架，我选它是因为它在移动端的优化相对来说比较好，然后大家可以学习到一些就是 work 的真正工程上优化的一些东西，然后最后我们要学习一下沃克的一些调试工具。调试工具其实是每个平台会需会有开发开放一个自己的调试工具。比如英伟达的有个insight， AMD 的有个 GPU profile，高通有个 snap Dragon 的profile，然后 arm 有 arm studio，现在每个平台硬件平台都会有他们自己的那个调试工具。然后这里我非常推荐叫 RENT doc 这个工具。这个工具是为什么呢？是因为它是一个图形开发人员来开发的一个工具，他非常知道图形开发人员想要工具变成什么样子。但是下面那些别的平台做的其实可能就是说我把所有的信息都给你了，好不好用我可能就不管了。OK，那么今天的课程就到此结束。嗯，我也非常感谢大家来听我的课程，那么我们下周三，下周三再见，拜。